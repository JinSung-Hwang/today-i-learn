# 1장 DBMS 아키텍처 개요

DBMS의 종류는 많고 특징도 다 다르지만 DBMS는 수학적이론을 바탕으로 만들어졌으며 기본적인 구조와 목적도 서로 같다. </br>
따라서 공통적인 특징을 이해한다면 각각의 DBMS의 특징도 쉽게 이해할 수 있다.</br>
먼저 공통적인 특성을 이해하기 위해서 DBMS의 아키텍처, DBMS와 버퍼, DBMS의 실행 계획등을 살펴보자. </br>

## 1강 DBMS 아키텍처 

### 1. 쿼리 평가 엔진
쿼리 평가 엔진은 SQL구문을 분석하여 실행 계획을 세우고 수행하는 DBMS의 핵심 기능을 담당하는 모듈이다. </br>

*실행계획: 어떤 순서로 기억장치에 데이터를 접근할지를 결정하는 계획을 말한다. </br>
*접근 메서드(access method): 실행계획을 기반으로 데이터에 접근하는 방법을 접근 메서드라고 부른다. </br>

### 2. 버퍼 매니저
DBMS에서 버퍼용도로 사용하는 메모리 영역을 말한다. </br>

### 3. 디스크 용량 매니저
디스크 용량 매니저는 데이터를 디스크에 어디에 어떻게 저장하고 읽고 쓸지를 결정한다.  </br>

### 4. 트랜잭션 매니저와 락 매니저
상용 서버에서는 동시에 여러 트랜잭션이 DBMS로 요청이 들어온다. </br>
이때 트랜잭션의 정합성을 관리하며 필요에 따라서 데이터에 락을 걸어 요청을 지연시키는 일을 관리하는 매니저를 말한다. </br>

### 5. 리커버리 매니저
DBMS의 장애 예방을 위해 백업을 하거나 장예 발생시 데이터 복구를 위한 모듈이 리커버리 매니저이다. </br>

## 2강 DBMS와 버퍼

### 1. 기억 비용과 버퍼
*기억비용: 데이터를 저장하는데 소모되는 비용을 말한다. ex) 하드디스크는 기억비용이 높고 메모리는 기억 비용이 낮다. </br>

많은 데이터를 영속적으로 저장하려면 속도를 잃고 속도를 얻고자 하면 많은 데이터를 영속적으로 저장하기 힘들다. **첫번째 트레이드 오프가 발생한다.** </br>
DBMS에서는 데이터를 디스크에 저장하여 데이터를 영속적으로 저장하고 관리한다. </br>
DBMS에서는 디스크에서 데이터를 조회하려면 시간이 오래걸리기 때문에 일부의 데이터라도 메모리에 저장하여 데이터 조회 성능을 향상 시킨다. </br>
이렇게 성능 향상을 목적으로 데이터를 저장하는 메모리를 버퍼라고 한다. </br>
버퍼는 사용자가 SQL 구문을 통해 데이터를 하드 디스크까지 읽어오는 시간을 단축시켜 성능을 향상시킨다. </br>

### 2. 메모리 위에 있는 3개의 버퍼
DBMS에서 메모리 사용은 3가지 용도로 나누어진다. </br>

1. 데이터 캐시: 디스크에 있는 데이터를 일부 메모리에 적재하여 정하는 공간을 말한다. </br>
2. 로그 버퍼: 갱신 처리(INSERT, UPDATE, DELETE)와 같은 SQL을 실행하면 바로 디스크의 내용을 갱신하지 않고 로그 버퍼에 기록해두었다가 백그라운드로 디스크로 기록한다. </br>
DBMS는 데이터 갱신처리를할때 메모리에만 기록하고 사용자에게 성공되었다고 알려주고 백그라운드로 데이터를 디스크에 저장한다. </br>
3. 워킹 메모리: 정렬 또는 해시 처리에 사용되는 메모리 영역을 말한다. </br>

### 3. 메모리 성질이 초래하는 트레이드오프

메모리의 2가지 문제점이 있다.</br>
1. 메모리의 가격은 비싸다.</br>
2. 메모리는 전원이 꺼지면 데이터가 사라지는 휘발성이다.</br>

DBMS에서 데이터를 갱신을 속도를 위해서 로그 버퍼에 데이터 변경점을 저장한다. </br>
하지만 DBMS의 장애가 발생하면 메모리에 있던 데이터는 휘발되어 사라진다.</br>
이런 장애 상황 대비를 위해서 Commit 명령이 일어날때마다 로그 버퍼의 내용을 디스크에 기록한다.</br>
Commit이 발생하면 지연이 발생하게 된다. 여기서 **두번째 트레이드 오프가 발생한다.**</br>
데이터의 변경점마다 동기적으로 Commit하면 정합성을 높아지지만 성능이 떨어진다.</br>
반면에 비동적으로 데이터를 처리하면 성능은 높아지지만 정합성은 낮아진다.</br>

### 4. 시스템 특성에 따라서 데이터 캐시와 로그 버퍼 크기의 설정하기

Oracle와 PostgreSQL은 기본 로그 버퍼가 1MB도 안된다. </br>
그 이유는 DBMS는 주로 조회가 많이 일어나며 데이터 캐시 영역을 많이 사용할거라 판단했기 때문이다. </br>
대다수의 어플리케이션이 조회가 많이 일어난다. </br>
하지만 그렇지 않는 어플리케이션도 있기 마련이기 때문에 어플리에키션의 읽기가 많은지 쓰기가 많은지에 따라서 데이터 캐시와 로그 버퍼의 크기를 조절해야한다.</br>
또한 데이터 캐시와 로그 버퍼의 크기 조절에 따라서 읽기와 쓰기 성능의 **트레이드 오프**가 발생한다.  </br>
데이터 캐시와 로그 버퍼의 크기를 조절했다면 성능 테스트를 반드시 진행해서 성능에 어떤 영향을 미치는지 확인해야한다. </br>

### 5. 추가적인 메모리 영역 '워킹 메모리'

워킹 메모리는 정렬이나, group, window function, 해시 처리 등에 사용되는 메모리 영역을 말한다. </br>
DBMS마다 MySQL은 정렬 버퍼, PostgrSQL은 워크 버퍼, Oracle은 PGA라고 부른다. </br>

DBMS에서는 워킹 메모리가 부족하면 디스크를 사용하여 워킹 메모리를 대신한다. (OS Spooling과 동일하다) </br>
이러면 메모리 대신 디스크를 활용하는것이기에 성능이 저하된다. </br>

Java는 메모리가 부족하면 OutOfMemoryError가 발생하여 프로그램이 종료되지만 DBMS는 메모리를 부족하여도 디스크를 사용하면서 계속성을 유지한다. </br>

## 3강 DBMS와 실행 계획

DBMS에서 데이터를 조회및 갱신을 하려면 SQL을 사용한다. </br>
SQL은 DBMS에 데이터를 어떻게 접근할지를 결정하는것(How)이 아니라 어떤 데이터를 가져올지(What)를 결정하는것이다. (선언형 프로그래밍) </br>

### 데이터를 접근하는 방법은 어떻게 결정될까?

DMBS에서는 아래 같은 절차에 따라서 실행 계획이 만들어진다.</br>

1. 파서: SQL 구분이 문법적으로 옳은지 검사하거나 SQL 구문은 정형적 형태로 변경해준다.</br>
2. 옵티마이저: SQL을 통해서 가장 효율적인 방식으로 데이터 접근 계획을 세운다.</br>
    1. 플랜 생성: 인덱스 유무, 데이터 분포도, DBMS 매개변수를 고려하여 최대한 많은 실행 계획을 생성한다.</br>
    2. 비용 평가: 만들어진 플랜들의 실행 비용을 계산한다. </br>
3. 카탈로그 매니저: 옵티마이저가 실행 계획을 세우기 위해서 데이터의 통계를 분포도 등을 파악하는 통계 테이블이 있는 모듈을 말한다. </br>
4. 플랜 평가: 많은 실행 계획을 비교 하여 가장 효율적인 실행 계획을 선택한다. </br>

### 옵티마이저와 통계 정보

옵티마이저가 실행 계획을 세울때는 카탈로그에 있는 통계 정보를 활용한다. </br>
이 통계 정보에 최신 데이터 통계가 있어야 실행 계획이 효율적으로 세워진다. </br>
만약 통계 정보에 데이터가 0건이 있는데 1억건을 넣은후 통계 정보를 갱신하지 않았다면 실행 계획이 효율적으로 세워지지 않는다. </br>
그렇다고 통계 정보를 자주 갱신하면 성능 저하가 발생할 수 있다. </br>

orcle은 정기적으로 통계정보를 갱신하고 ms-sql은 갱신이 일어날때마다 통계정보를 갱신한다. </br>
postgresql은 주기적으로 vacuum 작업을 통해서 갱신하고 mysql은 특정 이벤트가 발생할때 갱신한다. </br>
물론 자동으로 갱신하는것 이외에도 명령어를 통해서 통계 정보를 갱신할 수 있다. </br>

|DBMS| 통계정보 갱신 방법                                              |
|---|---------------------------------------------------------|
|Oracle| exec dbms_stats.gather_table_stats([스키마 이름], [테이블 이름]); |
|ms-sql| UPDATE STATISTICS [테이블 이름];                             |
|PostgreSQL| ANALYZE [스키마 이름].[테이블 이름]                               | 
|MySQL| ANALYZE TABLE [스키마이름].[테이블 이름]                          |


## 4강 실행 계획이 SQL 구문의 성능을 결정

Slow Query가 발생하면 실행 계획을 살펴봐야한다.</br>

|DBMS| 실행 계획 살펴보기 방법             |
|---|---------------------------|
|Oracle| set autotrace traceonly   |
|ms-sql| SET SHOWPLAN_TEXT ON       |
|PostgreSQL| EXPLAIN [SQL 구문]          |
|MySQL| EXPLAIN EXTENDED [SQL 구문] |

실행 계획의 포맷은 DBMS마다 다르지만 공통적으로 표시되는 항목이 있다. </br>
1. 조작 대상 객체: 테이블, 인덱스, 파티션 등이 있다. </br>
2. 객체에 대한 조작의 종류: 풀 스캔, 인덱스 스캔, 레인지 스캔 등이 있다. </br>
3. 조작 대상이 되는 레코드 수: 2번의 조작 방식을 통해서 몇개의 레코드에 접근하는지 표시한다. </br>
   이 숫자는 통계정보를 표시한것이기때문에 실제 쿼리 수행시 레코드 수와 다를 수 있다. </br>

조작 대상은 테이블, 인덱스, 파티션 등이 있다. </br>

```SQL
EXPLAIN SELECT shop_name
        FROM shops as s 
        INNER JOIN reservation as r on s.ship_id = r.ship_id;

QUERY PLAN
--------------------------------------------------------------------------------------
Nested Loop  (cost=0.15..14.80 rows=10 width=2)
    ->  Seq Scan on reservations r (cost=0.00..1.10 rows=10 width=6)
    ->  index scan pk_shops on shops s (cost=0.14..4.36 rows=1 width=8)
        Index Cond: (shop_id = r.shop_id)
```

실행 계획을 살펴보면 실행 순서는 아래와 같다. </br>
1. 실행 계획의 중첩 단계가 깊을수록 먼저 수행된다. </br>
2. 같은 중첩 단계에 있으면 위에서부터 실행 계획이 수행된다. </br>

중첩 단계가 깊고 위에있는 reservation 풀스캔이 일어나고 shop이 인덱스 스캔이 일어난다. 그 이후에 nested loop join이 일어난다. </br>
(reservation 스캔이 수행되고 수행 결과의 r.shop_id를 통해서 하나씩 shops에 인덱스 스캔을하면서 nested loop join이 일어난다.) </br>