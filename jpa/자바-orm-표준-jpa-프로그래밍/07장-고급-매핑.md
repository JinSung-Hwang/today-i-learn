# 7장 고급 매핑

고급 매핑에서 다룰 내용은 아래와 같다. 
1. 상속 관계 매핑: 객체 상속관계를 DB에 어떻게 맵핑할지 다룬다. 
2. @MappedSuperclass: 여러 엔티티에서 공통으로 사용하는 엔티티 속성을 상속받을때 사용하는 애노테이션이다.
3. 복합키와 식별 관계 매핑: 데이터베이스에 기본키가 하나이상의 복합키일때 매핑하는 법, 식별 관계와 비식별 관계에 대해서 이야기한다.
4. 조인 테이블: 테이블들의 관계를 외래키로 관계를 맵는것이 아니고 조인 관계 테이블로 매핑하는 방법을 말한다. (다대다 조인 테이블 말고는 잘 사용하지 않음)
5. 하나의 엔티티에 여러 테이블 맵핑하기:  하나의 엔티티를 여러 테이블에 맵핑하는 방법이다. (잘 사용하지 않음)

## 7.1 상속관계 매핑

RDB에서는 객체 지향 프로그래밍에서 이야기하는 상속이라는 개념이 없다. </br>
하지만 "슈퍼타입 서브타입 관계 모델링 기법(부모-자식테이블, 마스터-서브테이블)"이 있다. </br>
</br>
슈퍼 서브 논리 모델을 물리적 테이블로 구현하는 3가지 전략이 있다. </br>
1. 각각의 테이블로 변환(JPA Join전략)
2. 통합 테이블로 변환(JPA Single Table 전략)
3. 서브타입 테이블로 변환(JPA Table per Class 전략)

### 7.1.1 조인 전략
엔티티를 각각 테이블로 만들고 자식 테이블이 부모테이블의 기본키를 받아서 키본키 + 외래키로 사용하는 전략이다. </br>
마스터 테이블에는 공통 속성을 넣고 자식 테이블을 구분할 수 있는 칼럼을 넣는다. </br>

사용법 예제
```java
@Entity
@Inheritance(strategy = InheritanceType.JOINED) // note: 상속관계 매핑 전략을 명시한다.
@DiscriminatorColumn(name = "DTYPE") // note: 부모클래스에 자식 테이블 타입을 구분할 수 있는 칼럼을 생성한다.
public abstract class Item {
  @Id @GeneratedValue
  @Column(name = "ITEM_ID")
  private Long id;

  private String name;
  private int price;
}

@Entity
@EdsciminatorValua("A")
public class Album extends Item {
  private String artist;
}

@Entity
@DisciminatorValue("M") // note: 만약 영화 엔티티를 저장하면 DTYPE 칼럼에 "M"값이 저장된다.
public class Movie extends Item {
  private String director;
  private String actor;
}
```
#### 조인 전략의 장단점
장점
1. 테이블이 정규화된다.
2. 외래키 참조 무결성 제약조건을 활용할 수 있다.
3. 저장공간을 효율적으로 사용한다. (단일 테이블 전략에서는 Null이 들어가있는 캄럼이 많다.)

단점: 
1. 조회할떄 조인을 사용해야하기 때문에 성능이 저하된다.
2. 조회 쿼리가 복잡해진다.
3. 테이터 등록할때도 Insert Query를 두번 실행해야한다.

### 7.1.2 단일 테이블 전략
단일 테이블 전략은 하나의 테이블에 모든 엔티티를 통합하는 전략이다.

사용법 예제
```java
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE) // note: 상속관계 매핑 전략을 명시한다.
@DisciminatiorColumn(name = "DTYPE")
public abstract class Item {
  @Id @GeneratedValue
  @Column(name = "ITEM_ID")
  private Long id;
  
  private String name;
  private int price;
}

@Entity
@DisciminatiorValue("A")
public class Album extends Item { ... }

@Entity
@DisciminatiorValue("M")
public class Movie extends Item { ... }

@Entity
@DisciminatiorValue("B")
public class Movie extends Item { ... }
```
#### 단일 테이블 전략의 장단점
장점
1. 조인이 필요없어 조회 성능이 빠르다.
2. 조회 쿼리가 단순하다.

단점
1. 자식 엔티티가 맵핑한 칼럼은 null을 허용해야한다.
2. 단일 테이블에 모든 것을 저장하기에 테이블은 커지고 오히려 조회가 느려질 수 도 있다. </br>
   (만약 조회가 느려진다면 데이터가 많아서 느려지거나 하나의 테이블에 (Index, Gap, ...)Lock이 많이 걸려서 느려질 수도 있을거같다.)

### 7.1.3 구현 클래스마다 테이블 전략 (사용X)
구현 클래스마다 테이블 전략은 부모테이블은 없고 자식테이블마다 테이블을 만드는 전략이다.

사용법 예제
```java
@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS) // note: 상속관계 매핑 전략을 명시한다.
public abstract class Item {
  @Id @GeneratedValue
  @Column(name = "ITEM_ID")
  private Long id;
  
  private String name;
  private int price;
}

@Entity
public class Album extends Item { ... }

@Entity
public class Movie extends Item { ... }

@Entity
public class Movie extends Item { ... }
```

#### 구현 클래스마다 테이블 전략의 장단점 (사용X)
장점
1. 서브 타입을 구분해서 처리할 때 효과적이다.
2. not null 제약조건을 사용할 수 있다.

단점
1. 여러 자식 테이블을 조회할떄 성능이 느리다.(UNION Query를 사용해서 조회해야한다.)
2. 자식 테이블을 통합해서 쿼리하기 어렵다.

특징
1. 부모 테이블의 칼럼명을 자식 테이블들이 동일하게 사용한다.
1. 부모 테이블이 생성되지 않으며 부모 테이블에 있던 구분 칼럼을 사용하지 않는다.

## 7.2 @MappedSuperclass

@MappedSuperclass는 부모 클래스는 테이블에 맵핑하진 않고 상속 받은 자식 클래스에게만 맵핑 정보는 제공하는 애노테이션이다.

사용법 예제

```java
@MappedSuperclass
public abstract class BaseEntity { // note: 이 테이블을 생성할 일이 거의 없어서 abstract class를 사용한다.
   @Id @GeneratedValue
   private Long id;
   private String name;
}

@Entity
public class Member extends BaseEntity {
   // id 상속
   // name 상속
   private String email;
}

@Entity
public class Seller extends BaseEntity {
   // id 상속
   // name 상속
   private String shopName;
}
```
 특징
1. 부모 클래스는 테이블에 맵핑되지 않고 자식 클래스에게 맵핑 정보만 제공한다.
2. @MappedSuperclass가 선언된 클래스는 엔티티가 아니기에 em.find나 JPQL에서 사용 할 수 없다.
3. 이 클래스를 직접 사용할 일이 없어 추상클래스로 만드는 것을 추천한다.