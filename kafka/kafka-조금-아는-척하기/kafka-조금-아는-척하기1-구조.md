목차 
1. 카프카란?
2. 카프카 구조란?
3. 토픽과 파티션
   - 토픽이란?
   - 파티션이란?
4. 파티션과 오프셋, 메세지 순서
   - 파티션 파일의 특성?
   - 오프셋이란?
   - 메세지 순서가 보장되는가?
5. 여러 파티션과 프로듀서
6. 여러 파티션과 컨슈머
7. 카프카의 장점 
   * 성능
     - 카프카가 성능이 빠를 수 있는 이유 4가지?
   * 고가용성
     - 카프카가 수평확장이 용이한 이유는?
   * 장애 대응(리플리카)
     - 리플리카 구성은?
     - 프로듀서와 컨슈머가 통신하고 있는 대상은?
     - 리더와 팔로워란?

# 카프카(Kafka)란?

카프카란 고성능 분산 이벤트 스트리밍 플랫폼이다.

# 카프카 구조

![카프카구조](https://github.com/JinSung-Hwang/today-i-learn/assets/29647648/edae8ab1-18b3-42c0-9c74-f6ef7a8ab682)

카프카는 클러스터, 주키퍼, 프로튜서, 컨슈머로 구성되어있다. </br>
1. 클러스터: 메세지를 저장하는 저장소이다. 하나의 클러스터는 여러 브로커(서버)들이 모여서 클러스터를 이룬다. </br>
2. 주키퍼(앙상블): 카프카 클러스터를 관리하는 서버이다. 카프카 클러스터의 상태가 안좋으면 주키퍼가 대응을 진행한다. ex) 오토스케일링 </br>
3. 프로튜서: 카프카 클러스터에 메세지를 넣는 클라이언트이다. </br>
4. 컨슈머: 카프카의 클러스터에서 메시지를 가져오는 클라이언트이다. </br>

# 토픽과 파티션

토픽은 메시지를 나누는(구분하는) 단위이다. [폴더와 메일함과 비슷하다고 생각하면 된다.] </br>
파티션은 메시지를 저장하는 실제 물리적인 파일이다. </br>

카프카로 메세지를 보낼때는 프로듀서가 토픽을 설정하여 메세지를 전송하고 컨슈머가 토픽에 해당하는 메시지를 받아서 처리한다. </br>

# 파티션과 오프셋, 메세지 순서

파티션은 메세지를 저장한 물리적인 파일이다. </br>
파티션은 Append Only의 특성을 가져서 추가적으로 쓰기만 가능하다. (처음부분이나 중간에 메세지를 쓸 순 없다.) (한 파티션 내에서만 순서가 보장된다) </br>
Offset은 파티션에 메세지 저장하는 위치를 말한다. </br>
컨슈머는 Offset을 기준으로 메시지를 순서대로 읽는다.</br>
메시지는 삭제되지 않는다(설정에 따라서 일정 시간이후에 삭제한다.) </br>

# 여러 파티션과 프로듀서

![카프카프로듀서](https://github.com/JinSung-Hwang/today-i-learn/assets/29647648/fa259e21-706c-4509-aed5-14e5d7a3dde2)

프로듀서는 여러 파티션에 메세지를 쓸떄는 `라운드 로빈` 또는 `키`를 활용하여 여러 파티션에 나누어 메시지를 저장한다.</br>
(같은 키는 같은 파티션에 저장한다. 같은 키 끼리는 순서를 유지한다.)</br>

# 여러 파티션과 컨슈머
![카프카컨슈머](https://github.com/JinSung-Hwang/today-i-learn/assets/29647648/417cb951-e1e5-4476-afc6-e52113c31821)

컨슈머는 컨슈머 그룹에 속해있는다.</br>
한 개의 파티션은 컨슈머 그룹의 한개의 컨슈머만 연결이 가능하다.</br>

# 카프카 장점

![카프카리플리카](https://github.com/JinSung-Hwang/today-i-learn/assets/29647648/156bf608-d61e-4e37-a256-86826bdcab2c)

(카프카 리플리카 구조)

1. 성능
   Kafka 성능이 빠른 이유
   1. OS페이지 캐시를 사용한다. (파티션에 대한 파일 IO를 메모리에서 처리한다.)
   1. ZERO COPY를 사용한다. 디스크 버퍼에서 네트워크 버퍼로 다이렉트 카피를 한다.
   1. 클러스터가 재발송등 여러가지 일을 복잡하게 하지 않기에 성능이 빠르다.
   1. 묶어서 보내기, 묶어서 받기가 가능하다 -> 낱개 처리보다 처리량 증가
2. 고가용성
   1. 클러스터가 용량이 한계에 다다르면 브로커를 추가하기 쉬운 구조이기에 수평확장성이 좋다. 
   2. 컨슈머가 느리면 컨슈머를 늘리면 되기에 수평확장성이 좋다. 
3. 장애 대응
   리플리카: 파티션의 복제본이다.
   1. replication factor만큼 파티션의 복제본이 각 브로커에 생긴다.
   리더와 팔로워로 구성
   1. 프로듀서와 컨슈머는 리더를 통해서만 메세지를 주고 받는다.
   2. 팔로워는 리더로부터 복제한다.
   장애 대응
   1. 리더에 장애가 발생하면 팔로워가 리더가 되어서 프로듀서와 컨슈머에 메세지를 주고 받는다.

출처: https://www.youtube.com/watch?v=0Ssx7jJJADI
