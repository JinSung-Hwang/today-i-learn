
## 자바와 절차적 구조적 프로그래밍

### 자바 프로그램의 개발과 구동

자바의 구동 방법을 아는 것은 매우 중요하다.
자바는 JVM이라는 Java Virtual Machine이라는 가상 기계위에서 동작한다.

JDK - 자바 개발 도구: JVM용 소프트웨어 개발 도구 (자바 소스 컴파일러 javac.exe 포함)
JRE - 자바 실행 환경: JVM용 OS (자바 프로그램 실행기인 java.exe 포함)
JVM - 자바 가상 기계: 가상의 컴퓨터

자바는 자바 개발 동구인 JDK를 이용해 개발된 프로그램은 JRE에 의해 가상의 컴퓨터인 JVM상에서 구동된다.
JVM용으로 프로그램을 작성하면 JVM이 머신과 중재자가 되어서 각 플랫폼에서 구동하는데 아무 문제가 없게끔 만들어준다.
(CPU 아키텍처에 기계어가 다르기 때문에 기계어, 어셈블, C언어 같은 경우 CPU마다 컴파일러가 따로 존재하고 각 CPU에 맞게 컴파일해야한다.)
자바는 "Write Once, Run Anywhere" 철학을 가지고 있다.

#### 메모리

그림 2-2

프로그램 메모리는 "코드 실행 영역", "데이터 저장 영역"으로 나누어진다.

그림 2-3

이때 객체 지향 프로그램에서는 데이터 "데이터 저장 영역"을 "스태틱(static) 영역", "스택(Stack) 영역", "힙(Heap) 영역"으로 나누어진다.

스태틱 영역: 클래스의 놀이터
스택 영역: 메서드의 놀이터
힙 영역: 인스턴스의 놀이터

이때 스태틱, 스택, 힙 영역이 T형태로 보이기에 간략하게 T 메모리 구조라고 칭하겠다.

#### 다시 보는 Main() 메서드: 메서드 스택 프레임

아래 java소스가 실행될떄 T 메모리가 어떻게 변화하는지 살펴보자

```java
public class Start {
  public static void main(String[] args) {
    System.out.println('Hello World!!');
  }
}
```
실행 순서
1. JRE는 먼저 프로그램 안에 main() 메서드가 있는지 확인한다.
2. main()메소드가 확인되면 JVM을 전원을 넣어 부팅시킨다.
3. 부팅된 JVM은 목적파일을 받아 그 목적 파일을 실행한다.
(1~3까지가 전처리 과정이라고 부른다.)
4. 자바 모든 프로그램에 반드시 포함되는 패키지가 java.lang 패키지인데 이 패키지를 제일 먼저 "스태틱 영역"에 가져다 놓는다.
5. 임포트 패키지와 개발자가 작성한 모든 클래스를 "스태틱 영역"에 가져다 놓는다.
6. 클래스 여는 중괄호를 제외하고 모든 여는 중괄호는 스택 영역에 스택 프레임이 생긴다. main()의 스택프레임 생성
7. main() 스택프레임에 args변수를 공간을 확보한다.
   8. system.out.println() 코드가 실행되면서 GPU에 화면 출력을 의뢰한다.
9. main()에 닫는 중괄호를 만나면 main()스택프레임이 소멸된다.
10.  main()메소드가 소멸되면 JRE는 JVM을 종료시키고 JRE도 자체적으로 운영체제 상의 메모리에서 사라진다.

#### 블록과 메서드를 사용할떄 메서드 스택 프레임 

아래 코드는 책에서 if문이 있을때와 method가 있을때를 두개를 합친 코드이다.
```java
public class start3 {
  public static void main(String[] args) {
    int i = 10;
    int k = 20; // 4번째 줄
    if (i == 10) {
      int m = k + 5;
      k = m; // 7번째 줄
    } else {
      int p = k + 10;
      k = p;
    }
    // 12번째줄
    m = square(k); 
    // k = m + p;
  }
  
  private static int square(int k) {
    int result;
    k = 25;
    result = k;
    return result; // 21번째 줄
  }
}
```

4, 7, 12, 20번째 줄의 T메모리의 스냅샷을 살펴보자

[그림]
4번째 줄의 T메모리 스냅샷

[그림1]
7번째 줄의 T메모리 스냅샷

[그림2]
12번째 줄의 T메모리 스냅샷

12번째 줄이 되어서는 if블록의 지역변수들이 모두 사라진다.
따라서 "외부 블록에서 내부 블록의 변수는 접근할 수 없지만 내부 블록에서 외부 블록의 변수에 접근하는 것은 가능하다."
이것은 제임스 고슬링이 일부러 만드는 것이 아니라 메모리 변화에 따라서 당연히 그럴 수 밖에 없다는 결론이다.


[그림3]
20번째 줄의 T메모리 스냅샷

main()메서드의 지역 변수 m에 직접 접근할 수 있을까? 절대 접근할 수 없다.
메서드를 블랙박스화한다는 말을 들어본적 있을것이다.
이것은 입력 값들(인자 리스트)과 반환값에 의해서만 메서드 사이에서 값이 전달될 뿐 서로 내부의 지역 변수를 볼 수 없다는 것을 의미한다.

왜? 다른 메소드안에 변수를 참조하지 못하게 만들었을까?
1. 서로 무단으로 침범하게 하면 자바 월드에 문제를 유발할 수 있기 때문이다.
2. 포인터 문제이다. 다른 메소드의 지역 변수(m)에 데이터를 접근하기위해서는 다른 메소드의 지역변수(m)의 포인터 위치를 알아야하는데 자바에서는 포인터가 없다.
3. 예제코드에서는 sqaure()메서드에서는 main()메서드 내부에서만 호출하지만 실제 application에서는 다양한 곳에서 메서드가 호출된다. 
다양한 곳에서 메서드가 호출되면 스택 프레임은 개발자가 생각한것과 다르게 여러 스택프레임이 생기고 없어지는 상황일것이다. 
이때 다른 메서드의 지역변수를 참조하기 위해서는 포인터가 필요하다.
자바에서는 포인터를 사용할 수 없으므로 결국 언어 스펙상으로도 메서드 스택 프레임 사이에 변수를 참조하는 것을 불가능하다는 결론에 도달할 수 있다.

메소드 파라미터로 전달되는 변수 값은 포인터가 아닌가요?
포인터가 아니라 값을 복사해서 전달한다. 이런 방식을 call by value라고 한다.

#### 전역 변수와 메모리: 전역 변수 쓰지 말라니까요!

```java
public class Start5 {
  static int share;
  
  public static void main(String[] args) { // 4번쨰줄
    share = 55;
    
    int k = fun(5, 7); // 7번째줄
    
    System.out.println(share);
  }
  
  private static int fun(int m, int p) { // 12번째줄
    share = m + p; // 13번째줄
    return m - p;
  }
}
```
[그림 2-33]

코드를 보면 share변수에 static키워드가 붙어있다. 그래서 share변수는 T메모리의 스태틱 영역에 변수 공간이 할당된다. 

[그림 2-34]
4번쨰 줄을 실행하면 위 그림과 같을 것이다.

[그림 2-35]
12번째줄 실행후 T메모리 스냅샷

[그림 2-36]
13번째줄 실행후 T메모리 스냅샷
share변수에 m + p 값이 할당된것을 확인할 수 있다.

[그림 2-39]
마지막으로 16번째 줄이 실행후 T메모리 스냅샷
16번째 닫는 중괄호를 만나면 스택프레임이 사라지게 된다.

이렇게 static share변수를 이용하여 전역 변수(공유변수)를 살펴봤다.
(전역변수란 어디서든 접근 가능한 변수를 칭한다.)

그런데 전역 변수를 쓰지 말라고들 하는데 왜 그럴까?
프로젝트가 커지면 여러 메서드에서 전역 변수의 값을 변경하기 시작하면 T메모리로 추적하지 않는 이상 전역 변수에 저장되어있는 값을 파악하기 쉽지 않다.
다만 읽기 전용으로 값을 공유해서 전역 상수로 쓰는 것은 적극 추천한다. 
예를 들면 Math함수에서 PI속성은 전역 상수로 사용된다.
ex) Math.PI 

### 멀티 스레드/ 멀티프로세스의 이해

[그림 2-40]
멀티 스레드의 T 메모리 모델은 스택 영역을 스레드 개수만큼 분할해서 쓰는 것이다. 

[그림 2-41]
멀티 프로세스는 다수의 데이터 저장 영역, 즉 다수의 T메모리를 갖는 구조이다.

멀티 프로세스는 각 프로세스마다 각자의 T메모리가 있고 각자 고유의 공간이므로 서로 참조할 수 없다.
그에 반해 멀티 스레드는 하나의 T메모리만 사용하는데 스택 영역만 분할해서 사용하는 구조다.
멀티 프로세스는 하나의 프로세스가 다른 프로세스의 T메모리 영역을 절대로 침범할 수 없는 메모리 안전한 구조이지만 메모리 사용량은 그만큼 크다.

반면 멀티 스레드는 하나의 T메모리 안에서 스택 영역만 분할한 것이기 때문에 하나의 스레드에서 다른 스레드의 스택영역에는 접근할 수 없지만 스태틱 영역과 힙 영역은 공유해서 사용하는 구조다.
따라서 멀티 프로세스 대비 메모리를 적게 사용할 수 있는 구조이다.

자바 웹 프로그래밍을 공부해 본 적이 있다면 서블릿은 요청당 프로세스가 아닌 요청당 스레드를 생성한다는 말이 머릿속 어딘가에 콜 박혀있을것이다.
이제는 요청당 스레드(Servlet)가 요청당 프로세스(CGI)보다 왜 더 효율적인지 이해할 수 있을 것이다.

### 정리

사실 지금까지 공부한 2장은 객체 지향뿐만 아니라 현존하는 거의 모든 언어가 메모리를 사용하는 방식에 대해 설명한 것이다.

스태딕: 클래스의 놀이터
스택: 메서드의 놀이터
힙: 객체의 놀이터