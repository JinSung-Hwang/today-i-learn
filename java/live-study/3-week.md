백기선님의 Live-Study의 3주차 내용을 진행했다.

# 3주차 목표: 자바가 제공하는 다양한 연산자를 학습하기

## 할당 연산자
기본적으로 할당 연산자는 변수에 값을 저장하는 연산자를 말한다. </br>
하지만 개발하다 보면 반복적인 할당 연산자와 산술 연산자 형태를 많이 사용하기 때문에 이런 것을 간편하게 사용하기 위해서 여러 할당 연산자를 지원한다. </br>

`=`: 오른쪽 피연산자의 값을 왼쪽 피연산자에 저장한다. </br>
`+=`: 오른쪽 피연산자의 값을 왼쪽 피연산자와 더해서 왼쪽 피연산자에 저장한다.  </br>
`-=`: 오른쪽 피연산자의 값을 왼쪽 피연산자에서 빼서 왼쪽 피연산자에 저장한다. </br>
`*=`: 오른쪽 피연산자의 값을 왼쪽 피연산자와 곱해서 왼쪽 피연산자에 저장한다. </br>
`/=`: 왼쪽 피연산자를 오른쪽 피연산자로 나눠서 왼쪽 피연산자에 저장한다. </br>
`%=`: 왼쪽 피연산자에서 오른쪽 피연산자로 나눈 나머지(모듈러스)를 왼쪽 피연산자에 저장한다. </br>
`<<=`: 오른쪽 피연산자 값의 비트수만큼 왼쪽 피연산자를 왼쪽으로 이동해서 왼쪽 피연산자에 저장한다. </br>
`>>=`: 오른쪽 피연산자 값의 비트수만큼 왼쪽 피연산자를 오른쪽으로 이동해서 왼쪽 피연산자에 저장한다. </br>
`&=`: 왼쪽, 오른쪽 피연산자의 비트 AND를 구해서 왼쪽 피연산자에 저장한다. </br>
`|=`: 왼쪽, 오른쪽 피연산자의 비트 OR를 구해서 왼쪽 피연산자에 저장한다. </br>
`^=`: 왼쪽, 오른쪽 피연산자의 비트 XOR를 구해서 왼쪽 피연산자에 저장한다. </br>

## 산술 연산자
수학 산술 연산자는 기본적으로 사칙연산자(+, -, /, *)가 있다. </br>
자바에서는 이 사칙 연산자와 나누기의 나머지를 구하는 연산자(%)가 있다. </br>
산술 연산하면 타입 캐스팅 또는 타입 프로모션이 발생할 수 있어서 유심히 살펴봐야한다. </br>

추가적으로 + 는 프로그래밍 언어에서 풍부한 표현력을 위해서 문자열 연결도 수행한다. </br>
```java
public class Main {
  public static void main(String[] args) {
    int operand1 = 5;
    int operand2 = 5;
    
    System.out.println("operand1 + operand2 = " + (operand1 + operand2)); // 10
    System.out.println("operand1 - operand2 = " + (operand1 - operand2)); // 0
    System.out.println("operand1 * operand2 = " + (operand1 * operand2)); // 25
    System.out.println("operand1 / operand2 = " + (operand1 / operand2)); // 1
    System.out.println("operand1 % operand2 = " + (operand1 % operand2)); // 0
    
    System.out.println("Hello" + "World"); // Hello World
    }
}
```

## 비트 연산자
비트 연산자는 비트 단위로 연산하는 연산자를 말한다. </br>
비트 연산자를 하는 이유는 컴퓨터를 효율적으로 사용하기 위해서 이런 비트 연산자를 사용한다. </br>
요즘에는 컴퓨터가 하드웨어가 좋아져서 이런 비트 연산자를 많이 사용하지는 않지만 성능을 요구하는 분야에서는 비트 연산자를 사용하기도 한다. </br>
</br>
비트 연산자는 단한 연산자와 이항 연산자로 나누어진다. 

### 단항 비트 연산자
`~`: 비트를 반전한다. 1 -> 0, 0 -> 1로 비트가 반전된다.

### 이항 비트 연산자
`&`(And): 두 피연산자의 같은 자리가 모두 1이면 1을 반환하고 아니면 0을 반환한다. </br>
`|`(OR): 두 피연산자의 같은 자리중 하나가 1이면 1을 반환하고 모두 0이면 0을 반환한다. </br>
`^`(XOR): 두 피연산자의 같은 자리가 서로 다르면 1을 반환하고 0을 반환한다. </br>
`>>` (right SHIFT): 모든 비트를 한칸씩 오른쪽으로 이동한다. </br>
`<<` (left SHIFT): 모든 비트를 한칸씩 왼쪽으로 이동한다. </br>
`>>>` (**unsigned** right SHIFT) : 비트값을 오른쪽으로 이동 후 새로운 공간은 0으로 채운다. </br>

## 관계(비교) 연산자
관계 연산자는 두 값의 관계를 연산하는 연산자이다.

`==`: 서로 값이 같은지 비교한다. </br>
`!=`: 서로 값이 다른지 비교한다. </br>
`>`: 왼쪽 피연산자값이 오른쪽 피연산자 값보다 더 큰지 비교한다. </br>
`>=`: 왼쪽 피연산자값이 오른쪽 피연산자와 값이 같거나 큰지 비교한다. </br>
`<`: 왼쪽 피연산자값이 오른쪽 피연산자 값 보다 작은지 비교한다. </br>
`<=`: 왼쪽 피연산자값이 오른쪽 피연산자 값이 같거나 작은지 비교한다. </br>

## 논리 연산자
논리 연산자는 논리적인 조건을 판단하기 위한 연산자이다. </br>
기본적인 논리 연산자는 AND, OR, NOT 세가지이다. </br>

`&&(AND)`: 두 개의 조건이 모두 참일때 참의 결과 값을 반환한다. </br>
`||(OR)`: 두 개의 조건 중 하나가 참일때 참의 결과 값을 반환한다 </br>
`!(NOT)`: 주어진 조건을 반대로 바꿔 반환한다. 참이면 거짓을 거짓이면 참을 반환한다. </br>

## instanceof
실행 시간에 객체의 타입이나 속성을 검사하는 연산자이다. </br>
어떤 인스턴스가 어떤 객체에 속하는지 검사하기 위해서 사용한다. </br>
instanceof의 기본 사용방법은 "인스턴스 instanceof 클래스"문법을 통해서 사용한다. </br>
연산의 결과는 boolean값인 true, false 중의 하나를 반환한다. </br>

(참고로 null은 어떤 타입도 아니다.)

## 화살표(->) 연산자
람다식을 사용할때 메서드를 간편하게 표현하기 위한 연산자이다. </br>
java에서 기본적으로 메서드를 만들려면 이름, 반환 타입을 명시해야하지만, </br>
java8부터는 이것들을 명시하지 않고 "->" 문법을 통해서 익명 함수를 만들어서 사용할 수 있다. </br>

람다시 적용 이전
```java
public String main() {
    return "Hello World";
}
```
람다식 적용 이후
```java
() -> {
    return "Hello world";
}
```

## 삼항 연산자
피연산자를 3개를 갖는 연산자를 삼항 연산자라고 부릅니다. </br>
보통 3개의 피연산자 갖는 연산자가 `조건 ? 1식 : 2식`밖에 없기때문에 삼항 연산자라고 하면 이것을 떠올립니다. </br>
이 연산자는 if문을 간편하게 표현할 수 있어서 때로는 유용하지만 여러 중첩이 일어날 경우 가독성이 떨어질 수 있습니다. </br>
삼함 연산자는 `조건 ? 1식 : 2식` 형식을 갖는데 조건이 True를 반환하면 1식을 실행하고 False면 2식이 실행된다. </br>


## 연산자 우선 순위

| 우선순위 | 연산자                                          | 연산자 방향 |
|------|----------------------------------------------|--------|
| 1    | 괄호(), 대괄호[]                                  | -->    |
| 2    | 증감(++, --), 부호(+, -), 비트(~), 논리(!)           | <--    |
| 3    | 산술(*, /, %)                                  | -->    |
| 4    | 산술(+, -)                                     | -->    |
| 5    | 쉬프트(>>, <<, >>>)                             | -->    |
| 6    | 비교( <, >, <=, >=, instanceof)                | -->    |
| 7    | 비교(==, !=)                                   | -->    |
| 8    | 논리 &                                         | -->    |
| 9    | 논리 ^                                         | -->    |
| 10   | 논리  `\| `                                    | -->    |
| 11   | 논리 &&                                        | -->    |
| 12   | 논리 `\|\|`                                    | -->    |
| 13   | 조건 `? :`                                     | -->    |
| 14   | 대입 (=, +=, -=, *=, /=, &=, ^=, ^=, ...)      | <--    |

## Java 13. switch 연산자
if문이 ifelse등으로 길어질때 switch문을 통해서 좀 더 깔끔하게 코드를 표현하기 위해서 switch문을 쓰기도한다. </br>
또 enum을 사용하면 swtich문을 이용해서 각 타입에 따라서 프로그래밍을 하기도 한다. </br>

자바 12, 13에서는 switch문에 문법이 좀더 추가되었다. </br>
### Java12
1. -> 표현이 가능하고 data만 존재하면 return이 가능하다. </br>
2. -> 구문을 사용할 경우 `break;`를 적지 않아도 다음 case 구문으로 넘어가지 않는다. </br>
3. -> 은 중괄호(`{}`)를 통해서 여러 라인이 코딩이 가능하다.  </br>

### Java13
1. yield 예약어가 추가되었고 return 대신 yield를 통해서 리턴이 가능하다. </br>
2. yield는 예약어이지만 변수명으로 사용가능하다. </br>

### 사용법

```java
enum User {
  Staff,
  Master,
}

int result = switch(User) {
  case "Staff" -> {
    yield 10;
  }
  case "Master" -> {
    yield 20;
  }
  default -> throw new IllegalStateException("Unexcepted");
}
```

